---
source_url: ""
created: 2025-01-31 03:50:26
author: Cong Le
version: "1.0"
license(s): MIT, CC BY 4.0
---


# Chapter 5

## A Textual Summary


Chapter 5, "The Maintenance Process," from "Software Maintenance: Concepts and Practice," systematically explores the crucial role of process models in software maintenance. It begins by establishing the **importance of process models** as abstractions that help manage the complexity of software evolution, contrasting them with the broader software life-cycle which encompasses the cyclical nature of software from inception to obsolescence. The chapter highlights how models, using the analogy of maps and architectural drawings, provide essential representations for understanding and managing complex processes.

The chapter then critically appraises **traditional process models** – Code-and-Fix, Waterfall, and Spiral – through a maintenance lens. The **Code-and-Fix model** is presented as an ad-hoc, reactive approach, while the **Waterfall model**, though structured, is criticized for its linear, phase-based nature and inability to accommodate the iterative and evolutionary realities of software change and maintenance. The **Spiral Model**, with its risk-driven and cyclical approach, is presented as more flexible and adaptable, offering a framework that can incorporate other models.

The core of the chapter lies in the discussion of **maintenance process models**. It emphasizes the need for models specifically designed for maintenance, contrasting them with development-centric models.  Several distinct maintenance process models are examined:

*   The **Quick-Fix Model** is described as a reactive, "firefighting" approach, driven by immediate problem resolution, but lacking in long-term planning and potentially detrimental to code structure and maintainability.
*   **Boehm's Model** shifts the focus to economic considerations, highlighting management decisions and cost-benefit analysis as the driving force in the maintenance process, emphasizing a balance between objectives and constraints.
*   **Osborne's Model** adopts a pragmatic, real-world approach, acknowledging the often imperfect conditions of maintenance, such as incomplete documentation, and incorporating iterative loops for continuous improvement and adaptation.
*   The **Iterative Enhancement Model** leverages iterative development, applying it to maintenance by focusing on incremental enhancements and modifications to existing systems, assuming a base of existing documentation.
*   The **Reuse-Oriented Model** proposes a component-based approach, viewing maintenance as an opportunity to reuse existing program components to streamline changes and enhance efficiency.

The chapter then addresses the critical question of **when to make a change**, introducing the concept of decision-making processes within maintenance and hinting at the role of change control boards, which are explored in detail later in the book.

Moving beyond specific models, Chapter 5 delves into **process maturity**, introducing the **Capability Maturity Model® (CMM)** as a framework for assessing and improving the maturity of software processes within an organization. It outlines the five CMM levels, from "Initial" (ad hoc) to "Optimizing" (continuous improvement), emphasizing the progression from chaotic, individualistic processes to structured, standardized, and continuously improving ones.  The concept of **Software Experience Bases** is also introduced as a mechanism for organizational learning and knowledge sharing, aiming to capture and reuse valuable experience gained in software projects.

In **summary**, Chapter 5 provides a structured overview of software maintenance processes, moving from a critique of traditional development-focused models to an exploration of maintenance-specific models that account for the unique challenges of software evolution. It underscores the importance of choosing the right process model, understanding process maturity, and carefully considering the decision-making process behind implementing software changes within a maintenance context. The chapter lays the groundwork for the subsequent chapters by emphasizing the need for structured approaches and tools in managing the inherent complexity of software maintenance.





----
